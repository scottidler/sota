# flow-style type decl
Type1 = Type(object)
    .Type1 = (arg1, arg2)
        .arg1 = arg1
        .arg2 = arg2

# inline-style type decl
Type2 = Type(object) -> { .Type2 = (arg1, arg2) -> { .arg1 = arg1; .arg2 = arg2 } }

Color = Type(object)
    # constructor, assigning to properties
    .Color = (red, green, blue, alpha)
        .Red = red
        .Green = green
        .Blue = blue
        .Alpha = alpha

    # flow-style explicit property definition
    .Red =
        .get = ()
            return .red
        .set = (value)
            .red = value

    # inline-style explicit property definition
    .Green = { .get = () -> return .green; .set = (value) -> .green = value }

    # shorthand, implicit definitions
    .Blue = { .get; .set }
    .Alpha = { .get; .set }

# user-defined types must be capitalized
Point = Type(object)
    .Point = (x, y, z)
        .x = x
        .y = y
        .z = z

    # c++ style operator overloading
    .+ = (rhs)
        return Point(.x + rhs.x, .y + rhs.y, .z + rhs.z)

    .- = (rhs)
        return Point(.x - rhs.x, .y - rhs.y, .z - rhs.z)

    # c# style operator overloading, static with right and left side args
    Point.+ = (lhs, rhs)
        return Point(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z)

    Point.- = (lhs, rhs)
        return Point(lhs.x - rhs.x, lhs.y - rhs.y, lhs.z - rhs.z)

    # methods
    .MagnitudeSqrd = ()
        return .x ^ 2 + .y ^ 2 + .z ^ 2

    .Magnitude = ()
        return sqrt(.MagnitudeSqrd() ) # sqrt should come from some math library

main = ()

    type1 = Type1('sue', 37)
    type2 = Type2('sam', 42)

    red = Color(255, 0, 0, 0)
    green = Color(0, 255, 0, 0)
    blue = Color(0, 0, 255, 0)

    pt1 = Point(1, 2, 3)
    pt2 = Point(3, 5, 7)
    pt3 = pt1 + pt2
    mag = pt3.Magnitude()

    
